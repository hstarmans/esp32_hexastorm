import math
import logging
from machine import Pin as GPIO

from . import reg
from .uart import TMC_UART


logger = logging.getLogger(__name__)


class TMC_2209:
    """
    MicroPython UART configuration & diagnostics wrapper for the TMC2209 stepper driver.

    Scope:
      • No motion control here — STEP/DIR are generated by your FPGA.
      • Read driver status and diagnostics (GCONF/GSTAT/DRVSTATUS).
      • Configure chopper mode, microstepping, current, and thresholds.

    Bit names referenced in docstrings come from reg.py (e.g., reg.shaft, reg.vsense).
    """

    def __init__(self, pin_en, uart_dct, mtr_id=1, vref=1.2, rsense=0.11):
        """Initialize UART to TMC and the EN pin (active-low). Starts disabled (EN high)."""
        self.tmc_uart = TMC_UART(mtr_id=mtr_id, uart_dct=uart_dct)
        self._pin_en = pin_en
        self.p_pin_en = GPIO(
            self._pin_en, GPIO.OUT, value=1
        )  # EN high = disabled

        # microstep stats
        self._msres = -1
        self._stepsPerRevolution = 0

        # electrical model for mA<->CS conversions
        self._vref = float(vref)
        self._rsense = float(rsense)

        self.readStepsPerRevolution()
        self.clearGSTAT()
        self.tmc_uart.flushSerialBuffer()

    def __del__(self):
        """Disable motor driver and release EN pin on deletion."""
        logger.info("TMC2209: Deinit")
        try:
            self.motor_enabled = False
            if self.p_pin_en:
                deinit = getattr(self.p_pin_en, "init", None)
                if callable(deinit):
                    self.p_pin_en.init(GPIO.IN)
        except Exception:
            pass

    # ----------------------- Basic control -----------------------

    @property
    def motor_enabled(self):
        """True if outputs are enabled (EN low). EN is usually active-low on TMC2209 boards."""
        return not self.p_pin_en.value()

    @motor_enabled.setter
    def motor_enabled(self, en):
        """Enable/disable outputs via EN pin (active-low)."""
        if en:
            self.p_pin_en.off()
        else:
            self.p_pin_en.on()

    # ----------------------- Core status (read-only) -----------------------

    @property
    def drvstatus(self):
        """Raw DRVSTATUS (0x6F): motor state (reg.stst), mode (reg.stealth), and error flags (reg.ol*/s2*/*ot*)."""
        return self.tmc_uart.read_u32(reg.DRVSTATUS)

    @property
    def gconf(self):
        """Raw GCONF (0x00): general config (e.g., reg.i_scale_analog, reg.internal_rsense, reg.en_spreadcycle, reg.shaft)."""
        return self.tmc_uart.read_u32(reg.GCONF)

    @property
    def gstat(self):
        """Raw GSTAT (0x01): flags reg.reset, reg.drv_err (write-1-to-clear), reg.uv_cp."""
        return self.tmc_uart.read_u32(reg.GSTAT)

    def clearGSTAT(self):
        """Clear GSTAT.reset and GSTAT.drv_err (write-1-to-clear). Leaves other bits intact."""
        gstat = self.gstat | (reg.reset | reg.drv_err)
        self.tmc_uart.write_reg_check(reg.GSTAT, gstat)

    # ----------------------- Config properties -----------------------

    @property
    def direction_inverted(self):
        """True if motor shaft direction is inverted (GCONF.reg.shaft = 1)."""
        return (self.gconf & reg.shaft) != 0

    @direction_inverted.setter
    def direction_inverted(self, inverted):
        """Set GCONF.reg.shaft: True=invert motor direction."""
        self.tmc_uart.read_modify_write(
            reg.GCONF, reg.shaft, reg.shaft if inverted else 0
        )

    @property
    def iscale_analog(self):
        """True if current scaling uses external VREF (GCONF.reg.i_scale_analog = 1), False if internal 5VOUT."""
        return (self.gconf & reg.i_scale_analog) != 0

    @iscale_analog.setter
    def iscale_analog(self, en):
        """Set GCONF.reg.i_scale_analog."""
        self.tmc_uart.read_modify_write(
            reg.GCONF, reg.i_scale_analog, reg.i_scale_analog if en else 0
        )

    @property
    def internal_rsense(self):
        """True if internal sense resistors enabled (GCONF.reg.internal_rsense). Typically unsafe for external-Rsense boards."""
        return (self.gconf & reg.internal_rsense) != 0

    @internal_rsense.setter
    def internal_rsense(self, en):
        """Set GCONF.reg.internal_rsense (use with caution)."""
        self.tmc_uart.read_modify_write(
            reg.GCONF, reg.internal_rsense, reg.internal_rsense if en else 0
        )

    @property
    def spread_cycle(self):
        """True=SpreadCycle chopper (GCONF.reg.en_spreadcycle), False=StealthChop PWM."""
        return (self.gconf & reg.en_spreadcycle) != 0

    @spread_cycle.setter
    def spread_cycle(self, en):
        """Set GCONF.reg.en_spreadcycle."""
        self.tmc_uart.read_modify_write(
            reg.GCONF, reg.en_spreadcycle, reg.en_spreadcycle if en else 0
        )

    @property
    def interpolation(self):
        """True if interpolation to 256 usteps is enabled (CHOPCONF.reg.intpol)."""
        return (self.tmc_uart.read_u32(reg.CHOPCONF) & reg.intpol) != 0

    @interpolation.setter
    def interpolation(self, en):
        """Set CHOPCONF.reg.intpol."""
        self.tmc_uart.read_modify_write(
            reg.CHOPCONF, reg.intpol, reg.intpol if en else 0
        )

    @property
    def vsense(self):
        """True=high sensitivity, low sense voltage (CHOPCONF.reg.vsense). False=low sensitivity, higher sense voltage."""
        return (self.tmc_uart.read_u32(reg.CHOPCONF) & reg.vsense) != 0

    @vsense.setter
    def vsense(self, en):
        """Set CHOPCONF.reg.vsense."""
        self.tmc_uart.read_modify_write(
            reg.CHOPCONF, reg.vsense, reg.vsense if en else 0
        )

    # ----------------------- Microstep resolution -----------------------

    @property
    def microstep_resolution(self):
        """Current native microstep count (1..256). From CHOPCONF.msres[3:0] via (reg.MSRES_MASK >> reg.MSRES_SHIFT)."""
        chopconf = self.tmc_uart.read_u32(reg.CHOPCONF)
        field = (chopconf & reg.MSRES_MASK) >> reg.MSRES_SHIFT
        self._msres = 1 << (8 - field)  # 0 -> 256, 1 -> 128, ...
        return self._msres

    @microstep_resolution.setter
    def microstep_resolution(self, msres):
        """Set microstep resolution (power of two 1..256). Writes CHOPCONF.msres[3:0] and selects register control (GCONF.mstep_reg_select)."""
        if msres < 1 or msres > 256 or (msres & (msres - 1)) != 0:
            logger.warning("TMC2209: invalid microstep resolution: %s", msres)
            return
        field = 8 - int(math.log(msres, 2))
        self.setMStepResolutionRegSelect(True)
        chopconf = self.tmc_uart.read_u32(reg.CHOPCONF) & 0xFFFFFFFF
        chopconf &= ~reg.MSRES_MASK
        chopconf |= (field & 0x0F) << reg.MSRES_SHIFT
        self.tmc_uart.write_reg_check(reg.CHOPCONF, chopconf)
        self.readStepsPerRevolution()

    @property
    def steps_per_revolution(self):
        """Motor steps per full shaft revolution: 200 × microstep_resolution."""
        return self._stepsPerRevolution

    def setMStepResolutionRegSelect(self, en):
        """Set GCONF.reg.mstep_reg_select to choose microstep via register (True) instead of MS1/MS2 pins (False)."""
        self.tmc_uart.read_modify_write(
            reg.GCONF, reg.mstep_reg_select, reg.mstep_reg_select if en else 0
        )

    def readStepsPerRevolution(self):
        """Recalculate steps_per_revolution from current microstep setting."""
        self._stepsPerRevolution = 200 * self.microstep_resolution
        return self._stepsPerRevolution

    # ----------------------- Electrical model props -----------------------

    @property
    def vref(self):
        """Reference voltage (V) used for current calculations (datasheet equations)."""
        return self._vref

    @vref.setter
    def vref(self, value):
        """Set reference voltage (V) for current calculations."""
        v = float(value)
        if v <= 0.0:
            raise ValueError("vref must be > 0")
        self._vref = v

    @property
    def rsense(self):
        """Sense resistor value (Ohms) used for current calculations."""
        return self._rsense

    @rsense.setter
    def rsense(self, value):
        """Set Rsense (Ohms) for current calculations."""
        r = float(value)
        if r <= 0.0:
            raise ValueError("rsense must be > 0")
        self._rsense = r

    # ----------------------- Current as a property -----------------------
    # Flexible setter (mA or tuple or dict) + readable getter with CS & mA.

    def _vfs(self, vref=None):
        """Internal: Vsense-dependent full-scale voltage at Rsense, derived from CHOPCONF.reg.vsense and vref."""
        vref = self._vref if vref is None else float(vref)
        return (0.180 if self.vsense else 0.325) * vref / 2.5

    def _cs_from_run_mA(self, run_mA, vref=None):
        """Convert desired run current (mA) to CS value (0..31) using datasheet formula."""
        Vfs = self._vfs(vref)
        cs = (
            32.0
            * 1.41421
            * (float(run_mA) / 1000.0)
            * (self._rsense + 0.02)
            / Vfs
            - 1
        )
        cs = max(0, min(31, cs))
        return int(round(cs))

    def _mA_from_cs(self, cs, vref=None):
        """Estimate mA from a CS value using inverse of the datasheet formula."""
        Vfs = self._vfs(vref)
        i_a = (
            ((cs + 1) / 32.0) / 1.41421 * (Vfs / (self._rsense + 0.02))
        )  # Amps
        return int(round(i_a * 1000.0))

    @property
    def current(self):
        """
        Current configuration from IHOLD_IRUN:
        Returns dict:
          {
            "run_cs": int, "hold_cs": int, "hold_delay": int,
            "run_mA": int(approx), "hold_mA": int(approx),
            "vref": float, "rsense": float
          }
        (Bit fields: reg.ihold, reg.irun, reg.iholddelay)
        """
        val = self.tmc_uart.read_u32(reg.IHOLD_IRUN)
        hold_cs = (val >> reg.IHOLD_SHIFT) & 0x1F
        run_cs = (val >> reg.IRUN_SHIFT) & 0x1F
        hold_delay = (val >> reg.IHOLDDELAY_SHIFT) & 0x0F

        return {
            "run_cs": run_cs,
            "hold_cs": hold_cs,
            "hold_delay": hold_delay,
            "run_mA": self._mA_from_cs(run_cs),
            "hold_mA": self._mA_from_cs(hold_cs),
            "vref": self._vref,
            "rsense": self._rsense,
        }

    @current.setter
    def current(self, value):
        """
        Set current using any of:
          • int/float: run_mA (hold_multiplier=0.5, hold_delay=10)
          • (run_mA, hold_multiplier, hold_delay)
          • {"run_mA":..., "hold_multiplier":..., "hold_delay":..., "vref":...}
        Calculates IHOLD/IRUN/IHOLDDELAY (reg.ihold, reg.irun, reg.iholddelay).
        """
        if isinstance(value, (int, float)):
            run_mA = float(value)
            hold_multiplier = 0.5
            hold_delay = 10
            vref = self._vref
        elif isinstance(value, (tuple, list)):
            if len(value) < 1:
                raise ValueError("current tuple needs at least run_mA")
            run_mA = float(value[0])
            hold_multiplier = float(value[1]) if len(value) > 1 else 0.5
            hold_delay = int(value[2]) if len(value) > 2 else 10
            vref = self._vref
        elif isinstance(value, dict):
            if "run_mA" not in value:
                raise ValueError("current dict must contain 'run_mA'")
            run_mA = float(value.get("run_mA"))
            hold_multiplier = float(value.get("hold_multiplier", 0.5))
            hold_delay = int(value.get("hold_delay", 10))
            vref = float(value.get("vref", self._vref))
        else:
            raise ValueError("Unsupported current value type")

        run_cs = self._cs_from_run_mA(run_mA, vref=vref)
        hold_cs = int(round(max(0, min(31, hold_multiplier * run_cs))))
        hold_delay = max(0, min(15, hold_delay))

        ihold_irun = (
            ((hold_cs & 0x1F) << reg.IHOLD_SHIFT)
            | ((run_cs & 0x1F) << reg.IRUN_SHIFT)
            | ((hold_delay & 0x0F) << reg.IHOLDDELAY_SHIFT)
        )
        self.tmc_uart.write_reg_check(reg.IHOLD_IRUN, ihold_irun)

    # ----------------------- Thresholds & diagnostics -----------------------

    @property
    def stallguard_threshold(self):
        """SGTHRS (0x40): StallGuard threshold (lower value = more sensitive). (Field: reg.sgthrs[7:0])"""
        return self.tmc_uart.read_u32(reg.SGTHRS) & 0xFFFF

    @stallguard_threshold.setter
    def stallguard_threshold(self, threshold):
        """Set SGTHRS (0..255 typical)."""
        self.tmc_uart.write_reg_check(reg.SGTHRS, threshold & 0xFFFF)

    @property
    def coolstep_threshold(self):
        """TCOOLTHRS (0x14): Lower velocity threshold for CoolStep & StallGuard to DIAG."""
        return self.tmc_uart.read_u32(reg.TCOOLTHRS) & 0xFFFFF

    @coolstep_threshold.setter
    def coolstep_threshold(self, threshold):
        """Set TCOOLTHRS (unsigned)."""
        self.tmc_uart.write_reg_check(reg.TCOOLTHRS, threshold & 0xFFFFF)

    @property
    def ifcnt(self):
        """IFCNT (0x02): interface transmission counter (increments on successful UART transactions)."""
        return self.tmc_uart.read_u32(reg.IFCNT)

    @property
    def tstep(self):
        """TSTEP (0x12): Time between fullsteps in clock cycles (lower = faster)."""
        return self.tmc_uart.read_u32(reg.TSTEP)

    @property
    def stallguard_result(self):
        """SG_RESULT (0x41): Higher value means lower motor load (StallGuard)."""
        return self.tmc_uart.read_u32(reg.SG_RESULT)
